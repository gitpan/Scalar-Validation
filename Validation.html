<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#VERSION">VERSION</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#Validate-Subs">Validate Subs</a>
        <ul>
          <li><a href="#validate-parameter-and-par">validate(), parameter() and par()</a></li>
          <li><a href="#named_parameter-n_par">named_parameter(), n_par()</a></li>
        </ul>
      </li>
      <li><a href="#Dies-by-error-message">Dies by error message</a></li>
      <li><a href="#Just-check-without-die">Just check without die</a></li>
      <li><a href="#Get-validation-messages">Get validation messages</a></li>
      <li><a href="#As-parameter-check-for-indexed-arguments">As parameter check for indexed arguments</a></li>
      <li><a href="#As-parameter-check-for-named-arguments">As parameter check for named arguments</a></li>
      <li><a href="#Rules">Rules</a>
        <ul>
          <li><a href="#Special-Rules">Special Rules</a></li>
        </ul>
      </li>
      <li><a href="#Create-Own-Validation-Module">Create Own Validation Module</a>
        <ul>
          <li><a href="#Dealing-with-XSD">Dealing with XSD</a></li>
        </ul>
      </li>
      <li><a href="#Validation-Modes">Validation Modes</a>
        <ul>
          <li><a href="#is_valid">is_valid()</a></li>
          <li><a href="#Validation-Mode-die-default">Validation Mode &#39;die&#39; (default)</a></li>
          <li><a href="#Validation-Mode-warn-default">Validation Mode &#39;warn&#39; (default)</a></li>
          <li><a href="#Validation-Mode-ignore-default">Validation Mode &#39;ignore&#39; (default)</a></li>
          <li><a href="#Validation-Mode-off-default">Validation Mode &#39;off&#39; (default)</a></li>
        </ul>
      </li>
      <li><a href="#More-Examples">More Examples</a></li>
    </ul>
  </li>
  <li><a href="#LICENSE-AND-COPYRIGHT">LICENSE AND COPYRIGHT</a></li>
  <li><a href="#DISCLAIMER-OF-WARRANTY">DISCLAIMER OF WARRANTY</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Scalar::Validation</p>

<p>Makes validation of scalar values or function (sub) parameters easy, is fast and uses pure Perl.</p>

<h1 id="VERSION">VERSION</h1>

<p>This documentation refers to version 0.601 of Scalar::Validation</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>  use Scalar::Validation qw(:all);

  my $int_1    = validate int_1   =&gt; Int   =&gt; 123;
  my $float_1  = validate float_1 =&gt; Float =&gt; 3.1415927;

  my $para_1   = par  parameter_1 =&gt; -Range =&gt; [1,5] =&gt; Int =&gt; shift;
  my $exponent = npar -exponent   =&gt; -Range =&gt; [1,5] =&gt; Int =&gt; \%options;

  my $para_2     = parameter       parameter_1 =&gt; -Range =&gt; [1,5] =&gt; Int =&gt; shift;
  my $exponent_2 = named_parameter -exponent   =&gt; -Range =&gt; [1,5] =&gt; Int =&gt; \%options;

  my $int_2    = validate (int_2    =&gt; -And =&gt; [Scalar =&gt; &#39;Int&#39;],  123);
  my $int_3    = validate (int_3    =&gt; -Or  =&gt; [Int =&gt; &#39;CodeRef&#39;], 123);
  my $code_ref = validate (code_ref =&gt; -Or  =&gt; [Int =&gt; &#39;CodeRef&#39;], sub { 123; });

  my $enum_abc = validate (parameter =&gt; -Enum =&gt; {a =&gt; 1, b =&gt; 1, c =&gt; 1}, &#39;c&#39;);
  my $enum_abc = validate (parameter =&gt; -Enum =&gt; [ qw (a b c) ], &#39;c&#39;);

  my $int_4    = validate (int_4   =&gt; -Optional =&gt;  Int   =&gt;                             undef);
  my $int_5    = validate (int_5   =&gt; -Optional =&gt; -And   =&gt; [Scalar =&gt; Int =&gt; 0] =&gt;     undef);
  my $int_6    = validate (int_6   =&gt; -Optional =&gt; -Or    =&gt; [Int =&gt; CodeRef =&gt; 0] =&gt;    undef);
  my $enum_2   = validate (enum_2  =&gt; -Optional =&gt; -Enum  =&gt; {a =&gt; 1, b =&gt; 1, c =&gt; 1} =&gt; undef);
  my $range_1  = validate (range_1 =&gt; -Optional =&gt; -Range =&gt; [1,5] =&gt; Int =&gt;             undef);</code></pre>

<p>Just checks, never dies:</p>

<pre><code>  is_valid(valid_1 =&gt; Int =&gt; 123);   # is valid,     returns 1;
  is_valid(valid_2 =&gt; Int =&gt; 1.23);  # is not valid, returns 0;
  is_valid(valid_3 =&gt; Int =&gt; &#39;a&#39;);   # is not valid, returns 0;
  is_valid(valid_4 =&gt; Int =&gt; undef); # is not valid, returns 0;</code></pre>

<p>Free defined rules or wheres only (also for validate(...))</p>

<pre><code>  my $value = 2;

  # be careful, doesn&#39;t check that $_ is an integer!
  is_valid (free_where_greater_zero =&gt; sub { $_ &amp;&amp; $_ &gt; 0} =&gt; $value);  # is valid, returns 1

  is_valid (free_rule_greater_zero =&gt; { -as      =&gt; Int =&gt;
                                        -where   =&gt; sub { $_ &gt; 0},
                                        -message =&gt; sub { &quot;$_ is not &gt; 0&quot; },
                                      }
            =&gt; $value); # is valid, returns 1

  my $my_rule = { -as =&gt; Int =&gt; -where =&gt; sub { $_ &amp;&amp; $_ &gt; 0} =&gt; -message =&gt; sub { &quot;$_ is not &gt; 0&quot; };

  is_valid (free_rule_greater_zero =&gt; $my_rule =&gt; $value);              # is valid, returns 1</code></pre>

<p>Managing Rules</p>

<pre><code>  declare_rule (
      NegativeInt =&gt; -as      =&gt; Int =&gt;           # Parent rule is optional
                     -where   =&gt; sub { $_ &lt; 0 },
                     -message =&gt; sub { &quot;value $_ is not a negative integer&quot; },
  );

  rule_known(Unknown  =&gt; 1); # returns 0 (false)
  rule_known(Negative =&gt; 1); # returns 1 (true)</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This class implements a fast and flexible validation for scalars. It is implemented functional to get speed and some problems using global rules for all ;).</p>

<h2 id="Validate-Subs">Validate Subs</h2>

<p>Following validation functions exists:</p>

<pre><code>  validate(...);
    par(...);           # Alias vor validate()
    parameter(...);     # Alias vor validate()

  named_parameter(...);
    n_par(...);         # Alias for named_parameter()

  is_valid(...);</code></pre>

<h3 id="validate-parameter-and-par">validate(), parameter() and par()</h3>

<p>Different names for same functionality. Use like</p>

<pre><code>  my $var_float = validate (&#39;PI is a float&#39; =&gt; Float =&gt; $PI);
  my $par_int   = par      (par_int         =&gt; Int   =&gt; shift);</code></pre>

<p>First argument is a free name of the check done. If used as parameter check for subs it is the &#39;name&#39; of the parameter.</p>

<p>Last argument holds the value to be checked. It has to be a scalar, and therefore the module was named <code>Scalar::Validation</code>.</p>

<p>Optional last argument: After the value argument can be added a sub to print out an own error message instead of the default error message:</p>

<pre><code>  my $var_float = validate (&#39;PI is a float&#39; =&gt; Float =&gt; $PI =&gt; sub { &#39;wrong defined $PI: &#39;.$_ } );</code></pre>

<p>All parameters after first before value argument are used to select or define &quot;validation rules&quot;: &#39;Float&#39; and &#39;Int&#39; in this example.</p>

<h3 id="named_parameter-n_par">named_parameter(), n_par()</h3>

<p>These subs extract named parameters out of a parameter_hash_ref. Key and value will be deleted from hash during validation. After processing all parameters hash_ref should be empty.</p>

<pre><code>  my $par_1_int   = npar            (par_1 =&gt; Int   =&gt; \%parameters);
  my $par_2_float = named_parameter (par_2 =&gt; Float =&gt; \%parameters);</code></pre>

<p>First argument ($key) is the key of the parameter. Last argument ($parameters) has to be a hash_ref.</p>

<p>Without these subs you would have to implement for reading par_1:</p>

<pre><code>  my $key       = &#39;par_1&#39;;
  my $value     = delete $parameters-&gt;{$key};
  my $par_1_int = par ($key =&gt; Int   =&gt; $value);</code></pre>

<p>It could be done in one line, but this line will be complicated and not easy to understand. The key value is needed twice and that can cause Copy-Paste-Errors.</p>

<h2 id="Dies-by-error-message">Dies by error message</h2>

<p>On default, application dies with error message, if data checked by <code>named_parameter(...)</code> or <code>validate(...)</code> is not valid.</p>

<pre><code>  validate (parameter =&gt; -And =&gt; [Scalar =&gt; &#39;Int&#39;],  {} );
  validate (parameter =&gt; -And =&gt; [Scalar =&gt; &#39;Int&#39;],  [] );
  validate (parameter =&gt; -And =&gt; [Scalar =&gt; &#39;Int&#39;],  sub { &#39;abc&#39;; });</code></pre>

<h2 id="Just-check-without-die">Just check without die</h2>

<p><code>is_valid(...)</code> just does validation and returns 1 in case on success and 0 in case of fail.</p>

<pre><code>  print is_valid(parameter =&gt; -And =&gt; [Scalar =&gt; &#39;Int&#39;],  123) .&quot; =&gt; 123 is int\n&quot;;
  print is_valid(parameter =&gt; -And =&gt; [Scalar =&gt; &#39;Int&#39;],  {} ) .&quot; =&gt; {} is no scalar\n&quot;;
  print is_valid(parameter =&gt; -And =&gt; [Scalar =&gt; &#39;Int&#39;],  [] ) .&quot; =&gt; [] is no scalar\n&quot;;
  print is_valid(parameter =&gt; -And =&gt; [Scalar =&gt; &#39;Int&#39;],  sub { &#39;abc&#39;; }) .&quot; =&gt; sub { &#39;abc&#39;; } is no scalar\n&quot;;</code></pre>

<h2 id="Get-validation-messages">Get validation messages</h2>

<p>Per default, no messages are stored to increase performance. To store messages, the message store has to be localized into an array_ref.</p>

<p>This is the only safe way to deal with recursive calls and die! So use a block like this to store messages</p>

<pre><code>  my @messages;
  {
      local ($Scalar::Validation::message_store) = [];
  
      my $result = is_valid(parameter =&gt; -And =&gt; [Scalar =&gt; &#39;Int&#39;],  {} );
              
      @messages = @{validation_messages()} unless $result;
  }</code></pre>

<h2 id="As-parameter-check-for-indexed-arguments">As parameter check for indexed arguments</h2>

<p><code>Scalar::Validation</code> can be also used a parameter check for unnamed and named parameters. <code>parameters_end \@_;</code> ensures, that all parameters are processed. Otherwise it rises the usual validation error. Shorthand: <code>p_end</code>.</p>

<pre><code>  sub create_some_polynom {
      my $max_potenz = par maximum_potenz =&gt; -Range =&gt; [1,5] =&gt; Int =&gt; shift;
      # additional parameters ...

      p_end \@_;

      # --- run sub -------------------------------------------------

      my $polynom = &#39;&#39;;
      map { $polynom .= &quot; + &quot;.int (100*rand()).&quot;*x^&quot;.($max_potenz-$_); } (0..$max_potenz);

      return $polynom;
  };

  print create_some_polynom(1).&quot;\n&quot;;
  print create_some_polynom(2).&quot;\n&quot;;
  print create_some_polynom(3).&quot;\n&quot;;
  print create_some_polynom(4).&quot;\n&quot;;
  print create_some_polynom(5).&quot;\n&quot;;</code></pre>

<p>Dies by error message</p>

<pre><code>  print create_some_polynom(5.5).&quot;\n&quot;;
  print create_some_polynom(6).&quot;\n&quot;;
  print create_some_polynom(6, 1).&quot;\n&quot;;</code></pre>

<h2 id="As-parameter-check-for-named-arguments">As parameter check for named arguments</h2>

<p>Named arguments can also be handled. This needs more runtime than the indexed variant.</p>

<p><code>convert_to_named_params()</code> does a safe conversion by <code>validate()</code>.</p>

<pre><code>  sub create_some_polynom_named {
      my %pars = convert_to_named_params \@_;

      my $max_potenz = npar -maximum_potenz =&gt; -Range =&gt; [1,5] =&gt; Int =&gt; \%pars;
      # additional parameters ...

      parameters_end \%pars;

      # --- run sub -------------------------------------------------

      my $polynom = &#39;&#39;;
      map { $polynom .= &quot; + &quot;.int (100*rand()).&quot;*x^&quot;.($max_potenz-$_); } (0..$max_potenz);

      return $polynom;
  };

  print create_some_polynom_named(-maximum_potenz =&gt; 4);</code></pre>

<h2 id="Rules">Rules</h2>

<p>You can and should create your own rules, i.e.</p>

<pre><code>  declare_rule (
      Positive =&gt;  -as      =&gt; Int =&gt;           # Parent rule is optional
                   -where   =&gt; sub { $_ &gt;= 0 },
                   -message =&gt; sub { &quot;value $_ is not a positive integer&quot; },
  );

  rule_known(Unknown  =&gt; 1); # returns 0 (false)
  rule_known(Positive =&gt; 1); # returns 1 (true)</code></pre>

<p>The value to be validated is stored in variable <code>$_</code>. For</p>

<pre><code>  -message =&gt; sub { &quot;my message for wrong value $_.&quot;}</code></pre>

<p>it is enclosed in single ticks, so that you get the following output for <code>$_ = &quot;Garfield&quot;</code>:</p>

<pre><code>  my message for wrong value &#39;Garfield&#39;.</code></pre>

<p>Methods for replacing and removing rules will come soon.</p>

<h3 id="Special-Rules">Special Rules</h3>

<p>There are some special rules, that cannot be changed. Those rules start with an &#39;-&#39; char in front:</p>

<pre><code> -Optional    # value may be undefined. If not, use following rule
 -And         # all rules must be ok
 -Or          # at least one rule must be ok
 -Enum        # for easy defining enumeration on the fly, by array_ref or hash_ref
 -Range       # Intervall: [start, end] =&gt; type
 -RefEmpty    # array_ref: scalar (@$array_ref)     == 0
              # hash_ref:  scalar (keys %$hash_ref) == 0</code></pre>

<p>Reason is, that they combine other rules or have more or different parameters than a &quot;normal&quot; rule or using own implementation just to speed up.</p>

<p>All normal rules should not start with a &#39;-&#39;, but it is not forbidden to do so.</p>

<pre><code>  my $var_float = validate (&#39;PI is a float&#39; =&gt; -Optional =&gt; Float =&gt; $PI =&gt; sub { &#39;wrong defined $PI: &#39;.$_ } );</code></pre>

<p>This rule does not die, if $PI is undef because of -Optional in front.</p>

<h2 id="Create-Own-Validation-Module">Create Own Validation Module</h2>

<p>You should not use Scalar::Validation direct in your code.</p>

<p>Better is creating an own module My::Validation, that adds the rules you need and only exports the subs the developers in your project should use:</p>

<pre><code>  use My::Validation;

  my $v = validate v =&gt; my_type =&gt; new MyType();</code></pre>

<h3 id="Dealing-with-XSD">Dealing with XSD</h3>

<p>In this case My::Validation should create rules out of XML datatypes after reading in a XSD file. So rules are dynamic and your application can handle different XSD definitions without knowing something about XSD outside of this module.</p>

<p>Also you can filter XSD type contents, i.e. for enmuerations: Allowing not all possible values in UI or remove entries only for compatibility with old versions.</p>

<p>And your Application or GUI doesn&#39;t need to know about it.</p>

<h2 id="Validation-Modes">Validation Modes</h2>

<p>There are 4 predefined validation modes:</p>

<pre><code>  die
  warn
  ignore
  off</code></pre>

<h3 id="is_valid">is_valid()</h3>

<p><code>is_valid()</code> uses a special validation mode independent from the followings. It will do the checks in every case.</p>

<h3 id="Validation-Mode-die-default">Validation Mode &#39;die&#39; (default)</h3>

<p>The validation methods call <code>croak &quot;validation message&quot;;</code> in case of failures or a rule fails. Your script (or this part of your script) will die.</p>

<h3 id="Validation-Mode-warn-default">Validation Mode &#39;warn&#39; (default)</h3>

<p>The validation methods call <code>carp &quot;validation message&quot;;</code> in case of failures or a rule fails. Your get warnings for every failed rule.</p>

<p>Your script (or this part of your script) will NOT die.</p>

<p>It will continue work. In critical cases you should take care, that process will be stopped. One method is to store error messages and take care, that they are empty.</p>

<h3 id="Validation-Mode-ignore-default">Validation Mode &#39;ignore&#39; (default)</h3>

<p>The validation methods just store messages, if there is a message store available. No messages will be printed out.</p>

<p>Your script (or this part of your script) will NOT die.</p>

<p>It will continue work. In critical cases you should take care, that process will be stopped. One method is to store error messages and take care, that they are empty.</p>

<h3 id="Validation-Mode-off-default">Validation Mode &#39;off&#39; (default)</h3>

<p>The validation methods just give back the value. They even don&#39;t process the call parameters of the validation routines.</p>

<h2 id="More-Examples">More Examples</h2>

<p>Have a look into Validation.t to see what else is possible</p>

<h1 id="LICENSE-AND-COPYRIGHT">LICENSE AND COPYRIGHT</h1>

<p>Copyright (c) 2014 by Ralf Peine, Germany. All rights reserved.</p>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself, either Perl version 5.6.0 or, at your option, any later version of Perl 5 you may have available.</p>

<h1 id="DISCLAIMER-OF-WARRANTY">DISCLAIMER OF WARRANTY</h1>

<p>This library is distributed in the hope that it will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</p>


</body>

</html>


